First time doing a leetcode contest since weekly contest 8, so that's about 150 weeks or about 3 years XD

Solved all 4 problems for 269/6640 place (https://leetcode.com/contest/weekly-contest-158/)
wow, is this the first time I've ever finished all the problems in a contest?  Maybe...  Other than some easy hackerrank hour of codes.

1. A - Split a String in Balanced Strings - easy generalization of "are the parentheses balanced?" problem, also similar to "does array sum to 0" or "find subarrays that sum to 0".  (Just keep a running count of the net difference between "R"s and "L"s seen so far.  A 0 means no difference, which is perfectly balanced.)
2. B - Queens That Can Attack the King - pretty terrible problem.  I only know how to do stuff like this (searching in 8 directions, including diagonals) in a pretty tedious manner, although maybe there are slightly more elegant ways to do it.
3. C - Dice Roll Simulation - decent DP problem.  I think my DP formulation might have some wasted space (as in, the DP table might not need to be quite that big), but the constraints were small enough that it worked and was obvious.  Solution: DP table where DP[i][j][k] represents, after roll i, the number of different roll histories that end in a roll of value j (i.e. roll i had value j), and roll i was the kth roll with value j.  DP[i][j][k] = DP[i-1][j][k-1] + sum(DP[i-1][X][Y] for every other X != j, and every valid Y for each X).  Pretty obvious and easy to understand in one's head, but very difficult to try to explain in words.  Sorry.
4. D - Maximum Equal Frequency - the only interesting problem in the contest, but it was pretty interesting.  The n = 10^5 fooled me into thinking the solution was n log n, so I started thinking of what a tree data structure would need to keep track of in order to solve the problem.  After thinking for ten/twenty minutes, realized that we needed to be able to query the data structure for 1. number of values which have appeared MAX times, and 2. number of values which have shown up MAX-1 times, where MAX is the maximum, over all values, of the number of times a value has appeared thus far.  (aside: maybe things aren't hard to explain in words, but I've just gotten really bad at it) You also need to keep track of how many values have only appeared 1 time so far.  Then I realized we could keep track of all of these by just keeping a count of how many times each value has shown up so far - in a dict (let's call it count), so each operation is O(1). Then we keep track of how many values have shown up exactly X times, for each X.  We can also do this in a dict where count_of_count[X] = count of how many Y there are where count[Y] = X.  This can also be updated each time we encounter a new value in O(1). We know how many times the new value i has shown up already (it's stored in the count dict), so we just decrement count_of_count[num of times], and increment count_of_count[num of times +1].